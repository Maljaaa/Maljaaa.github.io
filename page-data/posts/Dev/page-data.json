{"componentChunkName":"component---src-templates-posts-template-index-tsx","path":"/posts/Dev","result":{"pageContext":{"currentCategory":"Dev","categories":["All","Dev","Experience","회고","React만들어보기","인턴회고","당근마켓시리즈"],"edges":[{"node":{"id":"53cf8da6-2004-52a0-897a-2e96634ee201","excerpt":"Git으로 협업을 하고 있다면 당연히 써봤을 clone과 fork 기능! 프로젝트 초기에 그라운드 룰을 정할 때면 항상 하게 되는 고민이 있다. 🤷‍♂️ 클론받아서 피쳐별로 브랜치 파서 main으로 PR 올릴까요? 🤷‍♀️ 포크 떠서 origin에서 upstream으로 PR 올리는 건 어때요?    Git Clone clone은 원격 저장소를 로컬 환경으로 복제해오는 방법이다. 이를 통해 원격 저장소에 있는 모든 코드, 히스토리, 브랜치 등을 로컬 환경에 가져올 수 있다.   Git Fork Fork는 다른 사람의 원격 저장소를 복제해서 내 저장소를 따로 만드는 방법이다. 즉, Fork를 한 후 내 저장소를 Clone해서 작업하게 되는 것이다.   보통 다른 프로젝트나 오픈소스에 기여할 때 Fork를 많이 사용하곤 한다. 원본 프로젝트와 완전히 분리된 환경에서 작업하여 코드를 안전하게 수정하고 실험할 수 있기 때문이다. 그렇다면 팀 프로젝트를 할 땐 어떻게 해야 할까?   Clone은 위험할…","fields":{"slug":"/46-clone-fork/"},"frontmatter":{"categories":"Dev","title":"Git clone과 fork, 뭘 써야할까?","date":"2023.08.08"}},"next":{"fields":{"slug":"/45-debounce-throttle/"}},"previous":null,"categoriesMap":{"Dev":true}},{"node":{"id":"e0b23b7f-9c76-57bf-9c92-29910d4cd905","excerpt":"input 또는 scroll 이벤트를 아무 생각 없이 다루다보면 내 의도와 다르게 엄청나게 많은 요청이 발생하게 되곤 한다. 예를 들어, 스크롤 이벤트가 걸려있는 상태에서 스크롤을 몇 천 픽셀 내리게 되면 100개 이상의 스크롤 이벤트에 대한 콜백이 발생할 것이고, 이는 엄청난 리소스를 잡아먹을 것이다..!  바로 이때 나 을 사용하여 이벤트나 함수의 실행 빈도를 줄여 성능을 높일 수 있다. 이벤트 핸들러가 많은 연산을 수행할 때, 제약을 걸어 제어할 수 있는 수준으로 이벤트를 발생시키게끔 하는 것이다. 그렇다면 이 둘의 차이는 뭘까?   Debounce 는 이벤트를 그룹화하여 특정 시간이 지난 후 하나의 이벤트만 발생하도록 하는 것이다. 즉, 연이어 호출되는 함수들 중 마지막 또는 제일 처음만 호출하도록 하는 것이다. 따라서 일정 시간 내에 이벤트가 계속 발생하면 함수가 실행되지 않다가, 이후 일정 시간 동안 이벤트가 발생하지 않으면 함수가 실행된다. 특히 텍스트 인풋에 글자를 …","fields":{"slug":"/45-debounce-throttle/"},"frontmatter":{"categories":"Dev","title":"이벤트 멈춰! Debounce와 Throttle","date":"2023.07.20"}},"next":{"fields":{"slug":"/44-wanted/"}},"previous":{"fields":{"slug":"/46-clone-fork/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"fc56cd05-e1d9-5e49-818c-fbe5b81fb4a2","excerpt":"타입스크립트는 자바스크립트의 상위 집합 언어로, 정적 타입을 지원하여 코드의 안정성과 생산성을 향상시켜준다. 이젠 더 이상 자바스크립트를 쓸 수 없는 몸이 되어버린..  그 중에서도 제네릭(Generic)은 타입스크립트의 핵심 기능 중 하나다. 오늘은 제네릭의 개념, 사용법, 그리고 실제 활용 방법에 대해 알아보자!   제네릭이란? 제네릭은 타입스크립트에서 코드의 일반화(generic)를 가능하게 해주는 기능이다. 제네릭을 사용하면 함수, 클래스, 인터페이스 등을 다양한 타입에 대해 작동하도록 만들 수 있다. 제네릭을 사용하면 컴파일 시점에서 타입 체크를 할 수 있어 런타임 에러를 사전에 방지할 수 있고, (타입 안정성) 한 번 작성한 제네릭 코드를 다양한 타입에 대해 재사용할 수 있고, (재사용성) 제네릭을 통해 일반적인 동작을 정의하고, 구체적인 타입은 사용하는 곳에서 결정할 수 있다. (추상화) 그렇다면 실제로 어떻게 제네릭을 사용하는지 살펴보자!   1. 함수 제네릭 함수를…","fields":{"slug":"/43-generic/"},"frontmatter":{"categories":"Dev","title":"타입스크립트의 꽃, 제네릭","date":"2023.07.16"}},"next":{"fields":{"slug":"/42-package-manager/"}},"previous":{"fields":{"slug":"/44-wanted/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"4d9eff0a-f657-56c7-9a14-c45d5720afb5","excerpt":"💡 깨알 상식 : etc.는 라틴어 et cetera의 줄임말이다.   자바스크립트 사용하는 사람~?  타입스크립트 사용하는 사람~?  외부 패키지 사용하는 사람~?    패키지 매니저란? 자바스크립트 프로젝트를 개발한다면 당연하게 사용하는 패키지 매니저! 자바스크립트 패키지 매니저는 자바스크립트 프로젝트에서 사용되는 의존성 관리 도구다. 패키지 매니저는 프로젝트에 필요한 외부 라이브러리, 모듈, 플러그인 등을 손쉽게 설치하고 관리하는 역할을 한다. 우리들의 만능 집사 패키지 매니저!    자바스크립트 패키지 매니저의 주요 기능은 다음과 같다. 패키지 설치 패키지 매니저를 사용하여 프로젝트에 필요한 패키지를 설치할 수 있다. 패키지는 일반적으로 오픈 소스 라이브러리이며, 패키지 매니저를 통해 패키지의 이름 또는 버전을 지정하여 설치할 수 있다. 의존성 관리 패키지 매니저는 프로젝트의 의존성을 관리한다. 패키지는 다른 패키지에 의존할 수 있으며, 패키지 매니저는 이러한 의존성을 자동…","fields":{"slug":"/42-package-manager/"},"frontmatter":{"categories":"Dev","title":"패키지 매니저, 뭘 쓸까? (npm, pnpm, yarn, yarn berry, etc.)","date":"2023.07.02"}},"next":{"fields":{"slug":"/41-jinhak-catch/"}},"previous":{"fields":{"slug":"/43-generic/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"a108a3e5-4358-5a70-8ae6-60c162b34590","excerpt":"1탄의 내용을 참고하여 이미지 업로드 미리보기를 구현해보자. 놀랍게도 그 방법은 한두 개가 아니다!    1. URL.createObjectURL 참고 자료: MDN web docs: URL.createObjectURL()  메서드를 사용하여 선택한 이미지 파일을 Blob 또는 File 객체로 변환하고, 그 객체를 URL로 변환하여 미리보기 이미지로 사용할 수 있다. 이 방법은 메모리 사용량이 적고 효율적이다. 하지만 URL은 사용이 완료되면 을 호출하여 메모리 해제를 해주어야 한다. 장점 간단하고 직관적인 방법으로 이미지를 미리보기할 수 있다. 추가적인 데이터 변환이나 처리 없이 바로 URL을 생성하여 사용할 수 있다. 메모리 관리에 대한 부담이 적다. 단점 생성된 URL은 페이지 세션이나 브라우저 세션 동안 유지되며, 페이지를 벗어나도 자동으로 해제되지 않는다. 큰 이미지 파일을 다룰 경우 메모리 사용량이 늘어날 수 있다.   2. FileReader.readAsDataURL …","fields":{"slug":"/40-image-upload-preview/"},"frontmatter":{"categories":"Dev","title":"<Blob File URL ArrayBuffer> 그들의 사각관계?! ~이미지 업로드 미리보기를 구현하고 싶습니다~ : 2탄","date":"2023.06.19"}},"next":{"fields":{"slug":"/39-file-blob-url-arraybuffer/"}},"previous":{"fields":{"slug":"/41-jinhak-catch/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"48929e83-7b5b-5b7d-96a0-8a6070810d0e","excerpt":"침착맨 라이트노벨 제목 월드컵 편을 보고 재밌어서 써본 제목입니다    파일을 다루는 일이 생길 때마다 구글링을 하게 되는 것 같다. 나만 그런 거 아니겠지?  여튼 그래서 들고와 본 주제!    Blob, File, 그리고 URL File, Blob, 그리고 URL은 웹 애플리케이션에서 파일과 데이터를 표현하고 다루는 데 사용되는 개념들이다. Blob Blob은 일련의 데이터를 나타내는 객체다. Blob은 Binary Large Object의 약자로, 텍스트나 이미지, 오디오, 비디오 등과 같은 다양한 종류의 데이터를 처리할 수 있다. File 객체는 Blob 객체의 하위 클래스로 볼 수 있다. File File은 사용자의 로컬 파일 시스템에서 선택한 파일을 나타내는 객체다. 일반적으로 파일 업로드나 파일 조작을 위해 사용된다. File 객체는 Blob 객체를 상속하며, 파일의 이름, 크기, 타입 등의 추가적인 정보를 가지고 있다. URL URL은 웹 리소스의 주소를 나타내는 문…","fields":{"slug":"/39-file-blob-url-arraybuffer/"},"frontmatter":{"categories":"Dev","title":"<Blob File URL ArrayBuffer> 그들의 사각관계?! ~이미지 업로드 미리보기를 구현하고 싶습니다~ : 1탄","date":"2023.06.18"}},"next":{"fields":{"slug":"/38-apps-script/"}},"previous":{"fields":{"slug":"/40-image-upload-preview/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"2340f145-a8d1-5c91-b0aa-7c33364e0def","excerpt":"현재 IT 동아리를 운영 중에 있는 나. SIPE 많관부탁드립니다 😉😉 구글폼으로 서류 원서를 접수받고, 서류 결과 메일을 보내야하는 상황에 다다르는데..   이거, 한 사람 한 사람 메일을 다 따로 보내야 하는 건가?    하지만 개발자로서 그런 노가다를 하는 것은 용납할 수 없는 일.  결국 구글에서 제공하는 API를 발견해내고야 말았다. 링크를 들어가보면 메일 말고도 다양한 API를 제공하는 것을 볼 수 있다.   1. 구글폼 상단의 를 클릭하면 응답을 스프레드시트로 확인할 수 있다.    2. 스프레드시트 메뉴의 를 클릭하자.    3. 코드를 작성하자!  이제 상단의 Run만 누르면 메일이 발송되는데, 정말 배포도 아닌 코드 실행이 이렇게 긴장되는 건 처음이었다. 이렇게 많은 수의 사람들에게 동시에 메일을 보내는 것도 처음인데다, 누군가에게는 불합격 소식을 전할 수밖에 없었기에 너무 죄송스러운 마음이 들기도 했다.    여튼 무사히 한 고비를 넘겼고, 이제 시작인 우리 S…","fields":{"slug":"/38-apps-script/"},"frontmatter":{"categories":"Dev","title":"구글 스프레드시트 메일 자동화: Apps Script","date":"2023.06.11"}},"next":{"fields":{"slug":"/37-event-loop/"}},"previous":{"fields":{"slug":"/39-file-blob-url-arraybuffer/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"6c58fad4-81f2-5ffc-803c-3bc78b5ff894","excerpt":"지난 글에서 에 대해 알아보았다. 어떤 독자는 해당 글을 읽으면서 한 궁금증이 떠올랐을지도 모른다. ‘왜 은 타이머 주기를 보장하지 않는 거지?’\n 이를 알기 위해서는 이벤트 루프에 대해 알아야 하는데, 우선 자바스크립트가 어떻게 동작하는지부터 알아보자.   자바스크립트의 동작 자바스크립트 엔진은 하나의 콜 스택을 가지는 싱글 스레드 모델로 동작한다. 하지만 현실에서 자바스크립트는 웹 브라우저나 노드js와 같은 멀티스레드 환경에 임베디드되어 실행되기 때문에 자바스크립트와 웹api, 이벤트 루프 등을 분리하여 말하기는 어렵다. 따라서 자바스크립트를 작동시킬 때는 싱글 스레드와 멀티 스레드의 타이밍이 따로 존재한다고 말할 수 있다. 일반적으로 프로그램은 코드를 위에서 아래로 순차적으로 실행하지만, 이벤트 루프를 통해 이벤트가 발생할 때마다 해당 이벤트에 대한 작업을 처리할 수 있다. 이를 통해 비동기 작업을 효율적으로 처리할 수 있고, 블로킹되는 작업 없이 다른 작업을 계속 수행할 수…","fields":{"slug":"/37-event-loop/"},"frontmatter":{"categories":"Dev","title":"이딴 게.. 타이머? 자바스크립트의 런타임과 Event Loop","date":"2023.06.10"}},"next":{"fields":{"slug":"/36-RAF/"}},"previous":{"fields":{"slug":"/38-apps-script/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"41571ff0-c3d0-5c13-a4fe-7ddb927688a2","excerpt":"과 이 정확한 타이머 주기를 보장하지 않는다는 사실, 알고 계신가? 과 이 불필요한 리소스를 소비할 가능성이 있다는 사실, 알고 계신가? 과 이 비동기적으로 작업을 비동기적으로 예약한다는 사실, 알고 계신가?      requestAnimationFrame이란? 은 브라우저에서 제공하는 메서드로, 애니메이션과 그 외의 반복 작업을 수행하기 위해 사용된다. 이 메서드는 브라우저의 리페인트 주기에 맞게 콜백 함수를 실행하도록 예약한다. 콜백 함수는 화면이 갱신되기 전에 실행되므로, 부드럽고 성능이 좋은 애니메이션 효과를 구현할 수 있다.   requestAnimationFrame을 사용해보자! 을 호출할 때, 실행하고자 하는 콜백 함수를 전달한다. 이 콜백 함수는 브라우저에서 리페인트 주기에 따라 호출된다. 콜백 함수는 브라우저에 의해 전달되는 단일 인수로 실행된다. 이 인수는  형식으로 제공되며, 애니메이션 시작 이후 경과한 시간을 나타낸다. 이 값을 활용하여 애니메이션을 제어할 수…","fields":{"slug":"/36-RAF/"},"frontmatter":{"categories":"Dev","title":"애니메이션을 그린다고요? setTimeout 싫어요! requestAnimationFrame 좋아요!","date":"2023.06.01"}},"next":{"fields":{"slug":"/35-css-module/"}},"previous":{"fields":{"slug":"/37-event-loop/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"e139c1f9-10b4-5993-97e8-29aa0fb06eea","excerpt":"개인적으로 보통은 styled-components나 emotion을 사용한 CSS-in-JS 기법을 많이 쓰는데, 이번 글에서는 생략하도록 하겠다.   외부 CSS 프레임워크를 쓰는 우리 팀. 하지만 CSS 프레임워크 하나로 모든 게 뚝딱 완성될 리는 없었다. 어쨌거나 CSS 커스터마이징이 필요했는데… \n🙋 “inline으로 커스텀할까요? 아니면 className을 추가할까요?”   Inline Style을 지양하자 위와 같이, 인라인 스타일은 HTML 요소의 style 속성을 사용하여 직접 스타일을 적용하는 방법이다. 인라인 스타일을 사용하면 간단하고 빠르게 스타일을 적용할 수 있다. HTML 요소에 직접 스타일을 작성하므로 별도의 CSS 파일을 만들 필요도 없다. 하지만 편리함이 있기에 단점도 있는 법. 인라인 스타일의 단점을 살펴보자. 코드의 재사용성이 떨어진다. 인라인 스타일은 요소마다 개별적으로 작성되기 때문에 스타일을 재사용하기가 어렵다. 유지보수가 어렵다. 스타일을 인…","fields":{"slug":"/35-css-module/"},"frontmatter":{"categories":"Dev","title":"CSS Module : 인라인(inline)은 나빠요!","date":"2023.05.30"}},"next":{"fields":{"slug":"/34-url/"}},"previous":{"fields":{"slug":"/36-RAF/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"38411151-f411-5c7d-b56f-9a71337b28b6","excerpt":"문득 개발을 하면서 라우팅을 하다가 궁금증이 떠올랐다. ‘왜 우리는 URL에 케밥 케이스를 사용하고 있지?’ 뇌 빼놓고 코딩하는 습관을 고치기 위해, URL 컨벤션에 대해 한 번 찾아보았다!\n   URL에서 케밥 케이스를 사용하는 이유 가독성과 사용자 친화성 URL은 사용자에게 직접 노출되는 요소다. 따라서 가독성이 좋고 사용자가 이해하기 쉬운 URL을 제공하는 것이 중요한데, 특히 케밥 케이스가 단어 사이에 대시를 사용하여 각 단어를 명확하게 구분해주기 때문에 가독성이 좋다. 특수 문자 제한 URL은 특수 문자를 제한하는 경우가 많다. 공백이나 다른 특수 문자를 URL에 직접 사용할 수 없기 때문에, 단어를 구분하는 데에는 특수 문자를 사용할 수 있는 유일한 방법은 대시(-)다. 케밥 케이스는 단어 사이에 대시를 사용하여 단어를 분리하므로, URL의 구조를 깨지 않고 유효한 문자만 사용하여 URL을 작성할 수 있다. 검색 엔진 최적화(SEO) URL은 검색 엔진 최적화에 영향을 …","fields":{"slug":"/34-url/"},"frontmatter":{"categories":"Dev","title":"URL엔 왜 케밥 케이스를 쓰는가?","date":"2023.05.29"}},"next":{"fields":{"slug":"/33-modal/"}},"previous":{"fields":{"slug":"/35-css-module/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"9289753f-0142-5900-bfc9-01e47d851e74","excerpt":"삐까뻔쩍 나도 한번 잘살아보자🎵 웹사이트를 만들다 보면 피할 수 없는 그것… 바로 모달 창 만들기..!  드롭다운이 아닌 일반적인 모달의 경우 화면 전체를 채우게끔 구현을 해야 하는데, 이 때 사용할 수 있는 몇 가지 팁을 정리해보려 한다. 현재 내 블로그에 있는  컴포넌트를 예시로 들어보도록 하겠다.   일단은 모달을 만들어보자 버튼을 클릭하면, 다음 사진처럼 모달이 열리게 된다.\n 자.. 그렇다면 닫히는 건 어떻게 해야 할까? 보통 모달은 모달 바깥을 클릭하면 닫히곤 한다.   모달 밖을 클릭하면 모달이 닫히게 하고 싶어! 여기에는 두 가지 방법이 있다. 1. ref 사용하기 ref를 사용해서 클릭 이벤트가 컴포넌트 내부에서 발생한 것이 아니라면 close를 해주는 방법이다.   2. Wrapper를 추가하기 모달을 감싸면서 화면 전체를 덮는 Wrapper를 추가하여 onClick 이벤트를 걸어주는 방법이다. 나는 어차피 모달 뒤에 배경을 넣어주고 싶었기에 Wrapper(Mod…","fields":{"slug":"/33-modal/"},"frontmatter":{"categories":"Dev","title":"React에서 모달 한번 잘 만들어보자 (feat. createPortal & ref)","date":"2023.05.26"}},"next":{"fields":{"slug":"/32-hosts/"}},"previous":{"fields":{"slug":"/34-url/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"77804b99-d5ad-5513-ad73-7b56aebac5cd","excerpt":"hosts 파일이란? hosts 파일은 운영체제가 호스트 이름을 IP 주소에 매핑할 때 사용하는 파일이다. 우리가 주소창에 url을 입력하면 DNS를 통해서 해당 도메인의 실제 IP 주소로 접속하게 되는데, 이 때 DNS를 통하지 않고 원하는 IP 주소로 접속하고자 할 때 hosts 파일을 수정하는 방법을 이용할 수 있다. 개발을 하다보면 로컬 환경에서 도메인 테스트를 해야 하는 경우가 생긴다. 이 때 원하는 도메인을 로컬 IP 주소를 바라보게끔 hosts를 수정할 수 있다.   sudo vi /etc/hosts vscode를 사용한다면 를 입력해도 된다. \n터미널에서 위 명령어를 입력하고 비밀번호를 입력하자. 그러면 아래와 같은 파일이 뜰 것이다. 나는 이미 수정된 내용이 있다.   입력 hosts 파일 수정  입력  (저장 후 종료) 입력   요즘은 이런 거 해주는 앱도 있더라 Gasmask와 같은 앱을 사용하는 것도 좋은 방법이다. 기존 hosts 파일을 직접 건드리지 않고 …","fields":{"slug":"/32-hosts/"},"frontmatter":{"categories":"Dev","title":"hosts 파일을 수정해서 local domain을 변경해보자!","date":"2023.05.23"}},"next":{"fields":{"slug":"/31-formdata/"}},"previous":{"fields":{"slug":"/33-modal/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"92a8f131-c8d3-5bb5-b33d-91243a0c9ee4","excerpt":"제목을 ‘form생form사’로 하고 싶었으나 처참히 실패 폼과 관련된 서버 통신 작업을 할 때, 보통은 이미지를 업로드하는 api와 폼데이터를 전송하는 api를 함께 사용해 서버로 데이터를 전송하곤 했다. 그러던 어느 날, 파일은 파일대로 json data는 json 대로 넣어서 하나의 api를 사용해 같이 전송해달라는 서버 개발자의 요청을 받게 되었는데…    FormData란? FormData는 HTML 폼 데이터로, 폼을 쉽게 보내도록 도와주는 객체다. 네트워크 메서드의 바디에 FormData 객체를 넣으면, HTTP 메시지는 인코딩되고  속성은 로 지정된 후 전송된다.   어떻게 동시에, 따로 보내야 하지? 그냥 다짜고짜 파일과 함께 보냈더니,  에러가 발생했다. 그래서 file은 multipart/form-data, 그 외의 데이터는 application/json 형식으로 따로 보내기 위해 Blob을 사용해주었다. Blob(Binary Large Object)은 이미지,…","fields":{"slug":"/31-formdata/"},"frontmatter":{"categories":"Dev","title":"file과 json data를 formData에 같이? 따로! 넣어보자","date":"2023.05.17"}},"next":{"fields":{"slug":"/30-cors-fe/"}},"previous":{"fields":{"slug":"/32-hosts/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"213ddc9d-949c-58a9-92bc-1e32529646e8","excerpt":"CORS 에러는 터지는데.. 아무힘이 없는 프론트 개발자가 과연 무얼 할 수 있을까?\n   CORS란? CORS (Cross-Origin Resource Sharing)는 웹 어플리케이션에서 다른 도메인의 리소스에 접근할 때 발생하는 보안 이슈를 해결하기 위한 표준 방법이다. CORS는 브라우저 단에서 작동하며, 웹 서버가 특정한 HTTP 헤더를 반환함으로써 웹 브라우저가 자원에 대한 권한을 부여하도록 한다. 이 헤더는 서버에게 특정한 도메인, 프로토콜, 포트에서만 요청을 허용하도록 지시할 수 있다. CORS는 웹 어플리케이션에서 다른 도메인으로부터 리소스를 요청하는 데에 있어서 발생하는 보안 문제를 해결한다. 이전에는 같은 도메인에서만 요청할 수 있었기 때문에, 다른 도메인으로 요청을 보내는 경우 보안 문제가 발생할 수 있었다. 그러나 CORS를 사용하면 다른 도메인에서도 자원에 접근할 수 있다. CORS는 다음과 같은 방법으로 작동한다. 브라우저는 HTTP 요청을 보낸다. 서버…","fields":{"slug":"/30-cors-fe/"},"frontmatter":{"categories":"Dev","title":"CORS 에러를 프론트에서 해결? 무시? 아무튼? 해보자!","date":"2023.05.09"}},"next":{"fields":{"slug":"/9-2022-retrospect/"}},"previous":{"fields":{"slug":"/31-formdata/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"dc2411b2-cec3-5024-839e-a3371757b032","excerpt":"JSX란? React는 별도의 파일에 마크업과 로직을 넣어 기술을 인위적으로 분리하는 대신, 마크업과 로직을 모두 포함하는 “컴포넌트”라고 부르는 느슨하게 연결된 유닛으로 관심사를 분리합니다. JSX도 결국엔 표현식입니다. 컴파일이 끝나면, JSX는 JavaScript 객체로 인식됩니다. 이전 글에서, 우리는 마크업과 해당 엘리먼트 내의 로직을 따로 분리하여 코드를 작성했었습니다. JSX를 구현하여 이를 함께 포함할 수 있도록 해봅시다! JSX를 구현한 후, 우리는 컴포넌트 내 렌더함수에서 다음과 같은 형태로 컴포넌트를 작성하게 될 것입니다. 위의 구조가 동작될 수 있게끔 JSX를 구현해보도록 하겠습니다. (Header의 props로는 스트링 타입의 와 함수 타입의 를 전달해주도록 하겠습니다.)   1. jsx 함수 기본 구조 우선 jsx 함수는 스트링 배열과 ${}에 포함된 아규먼트를 받아서, 공정을 거쳐 최종적으로 엘리먼트를 반환하게 됩니다. 초기 template은 div 엘리…","fields":{"slug":"/29-vanilla-spa-6/"},"frontmatter":{"categories":"Dev React만들어보기","title":"바닐라JS(TS)로 리액트 SPA 구현하기 | (6) JSX 구현해보기","date":"2022.05.18"}},"next":{"fields":{"slug":"/28-vanilla-spa-5/"}},"previous":{"fields":{"slug":"/10-depromeet/"}},"categoriesMap":{"Dev":true,"React만들어보기":true}},{"node":{"id":"33d486c8-9e66-5888-a059-ebcc51e5f1bb","excerpt":"컴포넌트와 라우터가 만들어졌으니, 한번 애플리케이션을 띄워봅시다!   src/index.ts   src/pages/Main.ts   src/pages/Sub.ts   src/components/Header.ts state와 props가 잘 동작하는지도 확인해보기 위한 코드도 함께 넣어주었습니다. 한 번 실행시켜 볼까요? 1. BrowserRouter의 경우    2. HashRouter의 경우    HashRouter의 경우 BrowserRouter와 다르게 이 들어가있는 것을 볼 수 있습니다. 두 경우 모두 state와 props가 잘 보여지고 있네요! 지금은  메서드로 string을 반환하여 UI를 그리고 있는데요, 때문에 클릭같은 이벤트도  메서드 내부에서 등록해주고 있는 것을 볼 수 있습니다. 다음 글에서는 jsx를 구현하여 더욱 효율적으로 엘리먼트를 그릴 수 있도록 해봅시다. src/index.ts src/pages/Main.ts src/pages/Sub.ts src/co…","fields":{"slug":"/28-vanilla-spa-5/"},"frontmatter":{"categories":"Dev React만들어보기","title":"바닐라JS(TS)로 리액트 SPA 구현하기 | (5) 간단한 웹 구현해보기","date":"2022.05.17"}},"next":{"fields":{"slug":"/27-vanilla-spa-4/"}},"previous":{"fields":{"slug":"/29-vanilla-spa-6/"}},"categoriesMap":{"Dev":true,"React만들어보기":true}},{"node":{"id":"298baa9e-5793-52a3-bbef-07648aa5c161","excerpt":"이번 글에서는 BrowserRouter를 구현해보도록 하겠습니다.   1. Route 타입 정의 이는 HashRouter와 동일합니다.   2. Router 구조 라우터 구조 또한 HashRouter의 경우와 똑같이 잡아주도록 하겠습니다. 다만 이번에는 가 아닌 로 네이밍해주었습니다.   3. Class 초기화 당연히 생상자 내부 코드도 동일하겠죠? 최상단 엘리먼트 객체, fallback url, 라우트들을 초기화해주고, 를 실행합니다.   4. hash가 변경될 때의 이벤트 처리 이제부터 HashRouter와 다른 로직이 등장하게 됩니다. HashRouter의 경우 Hash가 변경될 때 이벤트 처리를 해주었지만, BrowserRouter의 경우 history API를 사용합니다. 에서 window 객체의 이벤트 리스너에 핸들러를 등록해줍시다. 여기서 의문이 들 수 있습니다. document 객체의 이벤트 리스너에 라는 이벤트가 있었나? 싶을 텐데요. 맞습니다. document 객…","fields":{"slug":"/27-vanilla-spa-4/"},"frontmatter":{"categories":"Dev React만들어보기","title":"바닐라JS(TS)로 리액트 SPA 구현하기 | (4) 클래스로 BrowserRouter 구현","date":"2022.05.16"}},"next":{"fields":{"slug":"/26-vanilla-spa-3/"}},"previous":{"fields":{"slug":"/28-vanilla-spa-5/"}},"categoriesMap":{"Dev":true,"React만들어보기":true}},{"node":{"id":"011e807a-68da-52c3-8bae-111e2004310e","excerpt":"라우터를 구현하는 대표적인 방법에는 두 가지가 있습니다. 바로 BrowserRouter와 HashRouter인데요, 이 둘의 차이에 대해 잘 모르신다면 아래의 글을 먼저 읽어주세요! [BrowserRouter와 HashRouter, 뭐가 다를까? (feat. React Router)] HashRouter와 BrowserRouter를 모두 구현해 볼 텐데요, 이번 글에서는 HashRouter에 대해 먼저 다루어보도록 하겠습니다.   1. Route 타입 정의 라우트는 path와 해당 path에 해당하는 컴포넌트를 가지는 객체입니다.   2. Router 구조 SPA의 최상단 엘리먼트 객체와 정의된 라우트들을 필수적으로 받게 됩니다. 그리고 이벤트와 라우트를 다루는 여러 메서드를 통해 라우팅을 하게 됩니다.   3. Class 초기화 우선, 라우터 객체가 인스턴스화될 때의 설정을 생성자에서 해주어야겠죠. 최상단 엘리먼트 객체, fallback url, 라우트들을 초기화해주고, 를 실행…","fields":{"slug":"/26-vanilla-spa-3/"},"frontmatter":{"categories":"Dev React만들어보기","title":"바닐라JS(TS)로 리액트 SPA 구현하기 | (3) 클래스로 HashRouter 구현","date":"2022.05.15"}},"next":{"fields":{"slug":"/25-browserrouter-hashrouter/"}},"previous":{"fields":{"slug":"/27-vanilla-spa-4/"}},"categoriesMap":{"Dev":true,"React만들어보기":true}},{"node":{"id":"da8f0537-38c7-5029-815a-f2a7e1fafc96","excerpt":"CRA로 리액트 프로젝트를 생성하면, 기본적으로 react-router-dom을 사용하게 됩니다. 이 react-router-dom은 두 가지 라우터를 제공합니다. 바로 BrowserRouter와 HashRouter죠. 이 두 개념은 react-router-dom에만 해당되는 이야기는 아닙니다. BrowserRouter는 HTML5의 history API를 사용한 방식이고, HashRouter는 URL의 hash를 사용한 방식입니다. 리액트를 사용하지 않고 직접 라우터를 직접 구현한다 하더라도, 우리는 이 방식 중 하나를 선택할 수 있습니다.   react-router 우선은 리액트 라우터에 대해 잠깐 살펴봅시다. SPA가 등장하기 전에는 어떻게 페이지를 이동시켰을까요? 를 사용해서 직접 url을 변경시켰습니다. 하지만 이렇게 하면 모든 페이지를 reload하게 되므로 속도가 느려질 수밖에 없습니다. 리액트에서는 SPA라는 특성을 활용하여 라우터를 이용하여 변경된 소스만 바뀌도록 …","fields":{"slug":"/25-browserrouter-hashrouter/"},"frontmatter":{"categories":"Dev","title":"BrowserRouter와 HashRouter, 뭐가 다를까? (feat. React Router)","date":"2022.05.14"}},"next":{"fields":{"slug":"/24-vanilla-spa-2/"}},"previous":{"fields":{"slug":"/26-vanilla-spa-3/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"ed442853-bbac-5b7f-bae7-fb21c9b5e9b4","excerpt":"리액트 컴포넌트와 유사한 구조를 class로 만들어 봅시다!   1. Component 구조 target으로는 해당 컴포넌트가 들어갈 Element를 받게 됩니다. 컴포넌트는 부모로부터 받은 props와 스스로 관리하는 state를 가집니다. 컴포넌트 생명주기와 관련된 메서드, 첫 렌더링과 이후 상태가 변경되었을 때의 리렌더링을 위한 메서드, 상태 업데이트와 이벤트 등록과 관련된 메서드를 적어주었습니다. template 메서드에서는 실제 엘리먼트를 그리게 됩니다. 기본값으로는 빈 스트링을 반환하도록 해주었습니다.   2. \bClass 초기화 우선, 컴포넌트 객체가 인스턴스화될 때의 설정을 생성자에서 해주어야겠죠. 컴포넌트가 들어갈 Element를 받아 등록하고, props도 받아서 등록해줍니다. state는 빈 객체를 할당합니다. setup 메서드에서는 state 초깃값 선언, api 호출 등 컴포넌트가 렌더링되기 전에 일어나야 할 일들을 처리하는 용도입니다. 그 후 컴포넌트를 마…","fields":{"slug":"/24-vanilla-spa-2/"},"frontmatter":{"categories":"Dev React만들어보기","title":"바닐라JS(TS)로 리액트 SPA 구현하기 | (2) 클래스로 컴포넌트 구현","date":"2022.04.12"}},"next":{"fields":{"slug":"/23-vanilla-spa-1/"}},"previous":{"fields":{"slug":"/25-browserrouter-hashrouter/"}},"categoriesMap":{"Dev":true,"React만들어보기":true}},{"node":{"id":"e6297ae9-9eda-5826-9d3a-64631054d372","excerpt":"별도의 SPA 라이브러리 없이 Single page application을 만들어봅시다! 언어는 타입스크립트, 번들러는 웹팩을 사용하도록 하겠습니다. html과 css 웹팩 플러그인도 함께 설치하고, 바벨 트랜스파일러도 설치합시다. 저는 sass를 사용하기 위한 추가적인 설치를 함께 해주었습니다. devDependencies @babel/cli @babel/core @babel/preset-env @babel/preset-typescript babel-loader css-loader html-loader html-webpack-plugin mini-css-extract-plugin sass sass-loader ts-loader typescript webpack webpack-cli webpack-dev-server   1. webpack.config.js   2. tsconfig.json 절대 경로를 alias를 따로 설정해주었습니다.   3. .babelrc   4. index…","fields":{"slug":"/23-vanilla-spa-1/"},"frontmatter":{"categories":"Dev React만들어보기","title":"바닐라JS(TS)로 리액트 SPA 구현하기 | (1) 기본 세팅","date":"2022.04.10"}},"next":{"fields":{"slug":"/22-virtual-dom/"}},"previous":{"fields":{"slug":"/24-vanilla-spa-2/"}},"categoriesMap":{"Dev":true,"React만들어보기":true}},{"node":{"id":"e461cca8-06c0-573c-a2c4-a4c184e8fa05","excerpt":"DOM이란? DOM(Document Object Model)이란, 웹 페이지를 이루는 태그들을 브라우저가 트리 구조로 만든 객체 모델입니다. HTML과 자바스크립트를 이어주는 역할로 볼 수 있습니다. 자바스크립트로는 Document라는 전역 객체를 통해 HTML 태그들을 조종할 수 있습니다. 기존의 웹 애플리케이션은 자바스크립트로 직접 DOM을 제어했습니다. 이렇게 돔을 직접 제어하는 방식이 아닌, 리얼 돔을 추상화한 자바스크립트 객체를 구성하여 사용하는 방식이 가상 돔의 개념입니다.   SPA의 등장 전통적인 웹 사이트는 인터렉션이 발생할 때마다 완전히 새로운 페이지를 서버에서 전송해 주었습니다. 그러나 점차 웹 사이트가 고도화됨에 따라 한 페이지에 해당하는 페이지 용량이 커져갔고, 매번 새로운 페이지를 전달하는 게 점점 버거워지게 되었습니다. 또한 기존의 웹 애플리케이션은 돔 전체를 직접 접근하여 조작해서 브라우저에 화면을 나타내는 방식이었고, 웹 어플리케이션의 규모가 커질수록…","fields":{"slug":"/22-virtual-dom/"},"frontmatter":{"categories":"Dev","title":"SPA의 가상돔(virtual DOM)이란? 리액트의 휴리스틱 디핑 알고리즘","date":"2022.03.29"}},"next":{"fields":{"slug":"/21-rendering/"}},"previous":{"fields":{"slug":"/23-vanilla-spa-1/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"ccdcd7db-a42f-55ad-8fc9-13b4ded55874","excerpt":"렌더링이란? HTML, CSS, JS 문서가 브라우저에 출력되는 과정을 말합니다. 브라우저는 렌더링을 수행하는 렌더링 엔진을 가지고 있는데, 크롬은 블링크(Blink), 사파리는 웹킷(Webkit), 파이어폭스는 게코(Gecko)라는 렌더링 엔진을 사용합니다. 렌더링 순서는 다음과 같습니다. HTML 파일과 CSS 파일을 파싱해서 각각 Dom Tree와 CSSOM Tree를 만든다. (Parsing) 두 Tree를 결합하여 Render Tree를 만든다. (Style) Render Tree에서 각 노드의 위치와 크기를 계산한다. (Layout) 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고 레이어를 만든다. (Paint) 레이어를 합성하여 실제 화면에 나타낸다. (Composite)   1. Parsing 파싱  우선 HTML을 파싱하여 DOM(Documnet Object Model) Tree를 만들게 됩니다. 파싱 도중 CSS를 만나면 파싱하여 CSSOM(CSS O…","fields":{"slug":"/21-rendering/"},"frontmatter":{"categories":"Dev","title":"브라우저 렌더링 과정 및 사이드 이펙트(리플로우, 리페인트) 살펴보기","date":"2022.03.28"}},"next":{"fields":{"slug":"/20-mac-setting/"}},"previous":{"fields":{"slug":"/22-virtual-dom/"}},"categoriesMap":{"Dev":true}},{"node":{"id":"c417652f-a6e2-5cf1-96c2-26a5c2a97018","excerpt":"1. 기본 맥북 세팅 세 손가락 드래그 애플리케이션 창을 움직여 이동시키거나, 문서 내 글을 드래그할 때 클릭으로 하면 불편함이 많죠. 이걸 굳이 클릭해서 끌지 않아도, 간편하게 터치 & 드래그로 할 수 있는 방법이 있습니다. 시스템 환경설정 > 손쉬운 사용 > 포인터 제어기 > 트랙패드 옵션으로 들어가면 드래그 활성화 옵션이 있는데, 세 손가락으로 드래그하기로 설정해주면 됩니다. 저는 세 손가락으로 드래그 활성화를 하고, 페이지를 쓸어 넘기거나 Mission Control을 사용할 경우 네 손가락을 씁니다. 앱 expose 시스템 환경설정 > 트랙패드로 들어가면 앱 Expose를 켤 수 있습니다. 현재 포커스 된 탭과 동일한 애플리케이션 내의 탭들만 노출시키는 기능으로, 큰 기능은 아니지만 유용합니다.   2. 설치할 앱 이건 지극히 프론트를 하는 제 주관적인 의견입니다 크롬, 카카오톡, 노션, VScode, Zoom, Slack, Figma, Typora, iTerm2, Git…","fields":{"slug":"/20-mac-setting/"},"frontmatter":{"categories":"Dev","title":"맥북 마이그레이션이 필요 없을 정도로 간단한 \"맥북 + 개발 환경 세팅\" | iterm2 + ohmyzsh 테마 설정 (m1 기준)","date":"2022.03.05"}},"next":{"fields":{"slug":"/8-2021-retrospect/"}},"previous":{"fields":{"slug":"/21-rendering/"}},"categoriesMap":{"Dev":true}}]}},"staticQueryHashes":["1321405810","3649515864"]}